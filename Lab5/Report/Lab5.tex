\documentclass[letterpaper,12pt]{article}
\usepackage{tabularx,amsmath,boxedminipage,graphicx}
\usepackage[margin=1in,letterpaper]{geometry} % this shaves off default margins which are too big
\usepackage{cite}
\usepackage[final]{hyperref} % adds hyper links inside the generated pdf file
\usepackage{graphicx}
\usepackage{subfig}
\hypersetup{
	colorlinks=true,       % false: boxed links; true: colored links
	linkcolor=blue,          % color of internal links
	citecolor=blue,        % color of links to bibliography
	filecolor=magenta,      % color of file links
	urlcolor=blue         
}

\begin{document}

\title{ECE 232 Lab 5/6}
\author{Matthew Dombroski}
\date{April 27, 2016}
\maketitle

%  Abstract: A summary of the laboratory exercise, software that was implemented, data that was gathered, and
%  analysis that was completed.
%  • Code Implementation: A description of the code that was implemented to complete the lab. This is to be
%   written at the level of detail that qualitatively describes the files that were written and the purpose of the c++ functions that were implemented.
%  • Data and Data Analysis: The tables/plots of the data collected (as per the instructions of the  laboratory) and written descriptions of the observations.
%  • Laboratory Questions: Answers to the questions posted at the end of the laboratory.

 I affirm that I have not given or received any unauthorized help on this assignment,
and that all work is my own.
\begin{abstract}
The purpose of this lab was to implement an autonomous navigation system for navigating the robot through an obstacle course. The core concepts of the class such as localization, optimal path planning, and path following were implemented in one integrated system that successfully navigated the robot through the course in the simulator. 
\end{abstract}


\section{Code Implementation}
There were several overarching tasks needed in order to implement this lab. First the localizer needed to be updated so that it could handle multiple features within the map. Second a path planning algorithm needed to be implemented such that a path correctly navigating the course would be computed for each waypoint. An executive program to monitor the overall state of the robot and control the high level objectives was also implemented. Finally a path following algorithm needed to be implemented to command the robot to follow the path created by the planner within acceptable margins.

\subsection*{Localization} 
The first implementation of the localization algorithm was extremely simple, but provided reliable results in the simulator.
\\\\
The localizer worked by having a matrix $z_{est}$ store all of the predicted cone locations in relation to the robot. These values are updated for every cycle of localization whether or not a measurement for that cone was received. For every laser scan all the returns are filtered and the shortest overall return is selected. This returns range is then compared with all of the expected cone positions in the matrix $z_{est}$ and the cone with the highest correlation to the beam return is then selected as the beam feature correspondence. The beam return is then extended by the cone radius and the bearing, location, and correspondence are stored in the measurement vector z. The EKF algorithm will then update the robot pos and the expected cone positions based on this measurement. 
\\\
Some additional details for the localization are that the shortest beam return is correlated based upon the lest difference in distance between the beam return and cones - whichever cone is closest to the beam return is tentatively set as the correspondence for that beam. If the closest beam return is further than 2.5m away the beam return is rejected. If this test passes the bearing of the beam is then checked against the expected cone bearing and if it is within a certain tolerance based on the variance in St matrix, the correspondence is firmly set for that beam measurement. If any of these tests fail, the measurements are ignored and the EKF updates without a measurement. 
\\\\ 
In addition it was found that updating the EKF algorithm faster caused it to be more accurate. With more updates per time interval more data is processed by the algorithm and more potential beam returns are integrated into the pos estimation. The overall result was that even given certain drawbacks in the implementation of the EKF the results of the localization were still reliable and accurate. 
\\\\
Despite working well in the simulator this method of feature detection did not work well in the actual. The failure was the fact that only the shortest return was used. In the simulator this is fine as there are no spurious data points and any beam that misses the cone returns as a max range. However in the lab some beams returned as shorts - where the cone was farther out than the shortest beam return. This happened particularly often around the edges of the cones, for reasons unknown. Thus a new scheme for detecting the features was needed to more robustly detect the cones. Talking to students in the lab another approach was learned where that each beam return endpoint is transformed into global coordinates and the euclidean distance between the beam return and the center of each cone is computed. If this distance fell below a certain threshold for any cone on the map, the beam would be corresponded to that cone. So the result would be six vectors of vectors containing the beams that corresponded to each respective cone. Out of these vectors the shortest return for each cone correspondence is found and extended by the cones radius, resulting after appropriate transformations in the measured cone coordinates in relation to the robot. The EKF would then update with the measurements of every cone that was seen.
\\\\
In addition to the change in the feature finding algorithm the twist measurements from the robot base were fed into the EKF for the commands. It was found in the lab that there was a large discrepancy between the commanded velocities and the executed velocities, too much so to be compensated by the measurements from the cones. Thus given this fact and drawing from the improved performance other students had seen by doing this, using the twist messages was tried. Sure enough a great improvement was seen in the performance of the localizer. With more accurate velocities better predictions for both the cone locations and the robot location could be made, which helps and reinforces the measurement updates.  
\\\\
Some improvements that could be made to the localizer would be more tuning for the feature correspondence. Occasionally the algorithm mis-corresponds a cone which has negative impact on the robot pos estimation. Typically more than one cone was in sight so that the estimated pos would not be totally lost, but it is a problem to still be addressed. A possible solution would be to utilize a filtering method more similar to what was used in lab 4 in that beam returns are also compared to the variances in the St matrix. This would give a more probabilistic result that could be potentially more robust than the threshold method used currently. This method was not chosen for the project in the first place due to time constraints.
\\\\
Another improvement would be to use a circle fitting algorithm rather than radius extension. By incorporating more returns and more data and circle fitting algorithm can potentially give more accurate measurements for the center of the cones. Again due to time constraints and complexity the radius extension was kept as the method for finding the cone center. 

\subsection{Path Planner}
For planning the path of the robot A* with an 8 neighborhood connected grid was implemented. The main A* graph search was left unaltered and works as shown in class. The grid A* searches is created as the progressively using knowledge of the map and the current goal to determine the cost of motion from one node to the next. The discretization of the grid was chosen to be 0.25m as that was found to be a good balance between enough resolution to create a path to evade the cones without going very far out of the way and course enough for A* to run quickly. Discretizations of 0.1m and 0.01m were also tested however such fine discretizations had issues with having too many sharp edges causing the robot to turn excessively or did not produce timely solutions.
\\\\
Th base cost of motion to a node is dependent on the motion to get to that node. In an 8 connected grid some motions travel along a diagonal while others travel along an axis. Given that a diagonal motion travels a slightly longer distance it is weighted more than a motion along an axis. In the case of this implementation a movement along an axis is weighted at 1 and a motion along a diagonal is weighted at $\sqrt{2}$. This prevents zig-zagging paths that are in reality sub-optimal for reaching the goal. All other costs for traveling to a node are based on this initial cost. 
\\\\
Computing the cost between nodes was computed based on the particular motion, the distance of the destination node from a cone, and the orientation constraint for each waypoint. Given the grid is 8 connected the robot can move in any of 8 directions for each node being expanded. Reverse motion is suppressed implicitly by the fact that there will never be an optimal path to any waypoint that incorporates a reverse motion. If the robot became extremely unlocalized and somehow wound up ahead of the waypoint there could be a potential for a reverse path planned. However the localizer in this case would almost certainly never be able to re-localize and so the course traversal would result in failure anyway. Paths coming close to the cones are suppressed by computing the euclidean distance between the destination node and every cone in the map. If any of these distances falls bellow a certain threshold the cost to move to that node is increased by 50. The threshold distance was determined by adding the robots radius with the cone radius, plus a certain amount of expansion to give the robot some play to make up for any inaccuracies in the localization or rounded turns from the path follower. The resulting paths generally go travel directly between the cones in a straight line due to the inflated dimensions of the cones. Paths that would result in an incorrect orientation at the waypoint are weighted out by testing for what waypoint is being traveled to. For example, when traveling to waypoint 1 the robot needs to pass through the cones facing the negative y direction. Any motion resulting in the robot having a pos with a negative y component would thus be sub-optimal, as it would have to backtrack a long way to pass through the cones in the correct direction. Thus for waypoint 1 any node with a negative y component has 50 added to its cost.
\\\\
Some improvements or things to try for the planner were observed during other student's trials. One idea was to increase the cost of motion in the x direction, so that y-axis movement would be comparatively cheaper. The result is very wide arcs around the cones. During testing it was observed that at times the path would hug the cone and bring the robot very close to it. Inflating the cone size anymore however would start to cause A* to have convergence issues because the high cost regions would include the waypoints. Thus increasing x-axis movement could be a potential way to solve this issue. 

\subsection{Path Follower}
The path following algorithm implemented was pure pursuit. The overall path following controller receives the path from the planner and commands the robot to follow that path as closely as possible. To compute the lookahead distance first the projection point of the robot onto the path is computed and used as the origin point to start searching for the lookahead. This projection is useful because even if the robot is farther off the path than the lookahead distance this projection point can be used as the lookahead point to guide the robot back to the path. Otherwise the lookahead would come off the path and create nondeterminate behavior in the velocity commands. 
\\\\
After finding the closest closest path point the path from then on is discretized very finely. These points are examined one by one until the euclidean distance from the examined point and the closest path point is roughly equal to the lookahead distance, within some margin. Once a point is found it is returned as the lookahead point and used to compute the curvature and angular velocity given the deviation of the robots y coordinate from the lookahead. In the case of this project a linear velocity of 0.1m/s was chosen to minimize noise and uncertainty as much as possible. Given the paths produced by the planner and the velocity chosen a lookahead distance of 0.17m was chosen. Such a short lookahead was used as it was found that any greater of a distance caused the corners to be rounded too greatly, and the robot would run into a cone.  
\\\\
The PFC also tracks each waypoint it has passed and can detect when it has arrived at the goal point. Around each waypoint is a radial threshold which if the robot passes it is considered to have passed that waypoint. If the PFC detects that the next waypoint is the last waypoint of the path and the threshold has been passed it commands the robot to stop until the path is updated. 
\\ \\
Finally the angular velocity is bounded to be at max $\pi$ radians per second, which is the max rotational velocity of the Turtlebot. 

\subsection{Executive}
The executive for this project was integrated into the same file as the planner. This simplified the code a fair amount as there were many problems with getting ROS to communicate data in the correct sequence. The executive is preloaded with a list of goal points, the same points listed in the lab guide. The executive listens to the $\\pos$ estimates from the localizer and uses the predicted robot position to decide if a goal point is almost reached. If the robot is closer to the current goal than a certain threshold the executive pops off the next goal point and commands the planner to compute a path from the current goal to the next goal. This threshold for the executive is larger than the waypoint threshold in the PFC so that by time the robot reaches that waypoint the path has already been updated and the robot does not need to stop. As a consequence this goal threshold is determined by the expected runtime for A*. If the A* were to take a longer time to compute a path this threshold would need to be expanded out to give the algorithm time to get the path ready by time the robot almost exhausted the old path. In the case of this lab A* runs almost immediately so the threshold did not need to be expanded much.
\section{Data and Analysis}
Shown in Figures 1 and 2 are plots of the robots estimated position in both the simulator and from the trial in the lab. Note that the simulator uses the commanded velocities from the PFC and not the simulator, as the estimation would be perfect. It can be observed that the in lab robot pos estimation is much better than the simulator estimation. This would indicate that the localizer is heavily dependent on the commanded velocities from the robot, and that beam measurements are not as useful for the localization. More improvements to the feature detection algorithm would increase the accuracy of the predicted robot pos, both in the simulator and of the physical robot. Some improvements are discussed in the localizer section.
\\\\
Something to also note is that in my simulator implementation beams coming from the first quadrant looking into the direction of the origin do not compute correctly. Even if a cone is in view of the beams, the simulator does not represent them and appear to not be there, which denies the EKF from measurement updates in certain stages of the course. The problem lies with how bearing is represented in the simulator, however the simulation still works well enough to test code so the problem was never resolved. However, it does make the pos estimations worse for the return legs of the course. 




%++++++++++++++++++++++++++++++++++++++++

% References section will be created automatically 
% with inclusion of "thebibliography" environment
% as it shown below. See text starting with line
% \begin{thebibliography}{99}




% There is a fancier and in long run more convinient way to do bibliography 
% with automatic inclusion of references from the bibliography database
% file. See usage of "bibtex" if you are interested in it.
% http://www.bibtex.org/
% but for know we will go with hand formated list.
% Note: with this approach it is YOUR responsibility to put them in order
% of appearance.
%\begin{thebibliography}{99}


%\bibitem{melissinos}
%A.~C. Melissinos and J. Napolitano, \textit{Experiments in Modern Physics},
%(Academic Press, New York, 2003).

%\bibitem{Cyr}
%N.\ Cyr, M.\ T$\hat{e}$tu, and M.\ Breton,
% "All-optical microwave frequency standard: a proposal,"
%IEEE Trans.\ Instrum.\ Meas.\ \textbf{42}, 640 (1993).

%\bibitem{Wiki} \emph{Expected value},  available at
%\texttt{http://en.wikipedia.org/wiki/Expected\_value}.

%\end{thebibliography}


\end{document}
